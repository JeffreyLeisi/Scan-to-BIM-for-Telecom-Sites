\chapter{Case Study}
\label{sec:case_study}

\begin{German}
    Um die Wirksamkeit des entwickelten Frameworks unter realen Bedingungen zu demonstrieren und zu evaluieren, wurde eine Fallstudie durchgeführt. Dafür wurde eine Pipeline entwickelt, die auf dem zuvor entwickelten Framework basiert. 
    
    Die Fallstudie wurde in Zusammenarbeit mit Axians durchgeführt, einem international tätigen ICT-Unternehmen. Das Ziel bestand darin, aus einer gegeben Punktwolke ein Wohngebäude zu extrahieren, dieses weitestgehend automatisiert zu modellieren um anschliessend die für eine Baueingabe nötigen Pläne abzuleiten.     
\end{German}

\begin{English}
    To demonstrate and evaluate the effectiveness of the developed framework under real-world conditions, a case study was conducted. A pipeline was developed based on the previously established framework.
    
    The case study was carried out in collaboration with Axians, an internationally operating ICT company. The goal was to extract a residential building from a given point cloud, model it as automated as possible, and subsequently derive the plans required for a building application.
\end{English}


\section{Data Acquisition}
\begin{German}
    Die Datenaquisition wurde von Axians durchgeführt. Das Aufnahmedesign war somit nicht Teil der Fallstudie. Die Luftbilder wurden mit einer Drohne DJI Mavic 3 Enterprise aufgenommen. Die photogrammetrisch erzeugte Punktwolke deckte eine Fläche von ca. 700 x 500 m ab und enthielt ca. 33.1 Milionen Punkte.
\end{German}

\begin{English}
    The data acquisition was carried out by Axians. Therefore, the design of the acquisition was not part of the case study. The aerial images were captured using a DJI Mavic 3 Enterprise drone. The photogrammetrically generated point cloud covered an area of approximately 700 x 500 m and contained around 33.1 million points.
\end{English}

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|}
    \hline
    \textbf{Specification} & \textbf{Value} \\
    \hline
    Camera Model & DJI M3E (integrated) \\
    Sensor Size & 4/3'' CMOS \\
    Effective Resolution & 20 MP (5280 x 3956 pixels) \\
    RTK Support & Yes (integrated RTK module) \\
    \hline
    \end{tabular}
    \label{tab:m3e_camera_specs}
    \caption{Key camera specifications of the DJI Mavic 3 Enterprise (M3E) \cite{SpecsDJIMavic}}
\end{table}


\section{Preprocessing}
\begin{German}
    Zunächst wurde mit dem Open-Source-Tool \textit{CloudCompare} das Zielgebäude isoliert. Die Segmentierung erfolgte manuell, indem in der Draufsicht eine Box mit rund 1 m Abstand um das Gebäude aufgespannt wurde. Die Punktanzahl wurde damit auf ca. 780'000 Punkte reduziert.

    Anschliessend wurde die Punktwolke mit einem in Python implementierten Statistical Outlier Removal (SOR) Filter bereinigt. Punkte wurden entfernt, wenn seine durchschnittliche Distanz zu den 20 nächsten Nachbarn grösser war als der globale Mittelwert dieser Distanzen plus zwei Standardabweichungen. Damit wurden ca. 35'000 Punkte entfernt, was einer Reduktion um 4.5\% entspricht. Die verbleibende Punktwolke enthielt noch ca. 745'000 Punkte.

    Anschliessend wurde die Punktwolke mittels Voxel-Grid-Downsampling weiter reduziert. Es zeigte sich, dass das durch die geometrische Rekonstruktion generierte Mesh von der Punktanzahl und damit indirekt von der gewählten Voxel-Grösse abhängt. Die Voxel-Grösse kann somit, neben den drei PolyFit-internen Lambda-Gewichten, als zusätzlicher Parameter zur Steuerung der geometrischen Rekonstruktion betrachtet werden. Da sie sich in der Fallstudie als der einflussreichste Faktor erwies, wurde ausschliesslich die Voxel-Grösse als Hyperparameter berücksichtigt.
\end{German}

\begin{English}
    First, the target building was isolated using the open-source tool \textit{CloudCompare}. The segmentation was performed manually by drawing a box around the building in the top view with approximately 1 m distance. This reduced the point count to about 780,000 points.

    Next, the point cloud was cleaned using a Statistical Outlier Removal (SOR) filter implemented in Python. Points were removed if their average distance to the 20 nearest neighbors was greater than the global mean of these distances plus two standard deviations. This removed approximately 35,000 points, resulting in a reduction of about 4.5\%. The remaining point cloud contained around 745,000 points.

    Subsequently, the point cloud was further reduced using voxel grid downsampling. It was observed that the mesh generated by geometric reconstruction depends on the number of points and thus indirectly on the chosen voxel size. The voxel size can therefore be considered an additional parameter for controlling the geometric reconstruction, alongside the three PolyFit-internal lambda weights. Since it proved to be the most influential factor in the case study, only the voxel size was considered as a hyperparameter.
\end{English}

\section{Geometric Reconstruction}
\begin{German}
    Die geometrische Rekonstruktion wurde mithilfe des PolyFit-Frameworks in Python durchgeführt. Der in C++ geschriebene Quellcode wurde auf GitHub bereitgestellt \cite{nanLiangliangNanPolyFit2025}. Um die Funktionen in Python nutzen zu können, wurde mit CMake ein entsprechendes Python-Binding erstellt. Für den ersten Schritt des PolyFit-Workflows - die Flächenextraktion mittels RANSAC - wurde zusätzlich die Python-Bibliothek \textit{Easy3D} benötigt, die ebenfalls an der TU Delft entwickelt wurde \cite{nanLiangliangNanEasy3D2025}.

    Da die Bindings manuell passend zur Zielplattform (Betriebssystem und Python-Version) kompiliert werden müssen, gestaltet sich der Setup-Prozess vergleichsweise aufwändig. Das entwickelte Skript kann daher nicht ohne Weiteres von anderen Benutzerinnen und Benutzern übernommen werden, was den produktiven Einsatz der Pipeline derzeit einschränkt.

    Für die geometrishce Rekonstruktion konnten keine invariante Parameter gefunden werden, die für unterschiedliche Gebäude zuverlässig gute Mesh-Modelle produzieren. Daher wurde ein Brute Force-Ansatz gewählt, bei dem die Voxel-Grösse durchiteriert wurde, um eine vielzahl an Mesh-Modellen zu generieren. Anschliessend wurde das Modell mit der subjektiv besten Qualität ausgewählt. Dieses Modell entstand aus einer Punktwolke mit ca. 87'000 Punkten, was ca. einem Zehntel der ursprünglichen Punktwolke entspricht. Ab einer Punktanzahl von ca. 150'000 Punkten wurde das Optimierungproblem zu komplex und führte zum Abbruch des Programms. Für die Berechnung wurde der open-source-Solver SCIP verwendet. Der komerzielle Gurobi-Solver ist für wissenschaftliche Projekte kostenfrei erhältlich und soll eine bessere Performance bieten \cite{nanLiangliangNanPolyFit2025}, was eine höhere Punktanzahl ermöglichen könnte. Da die Modellqualität aber bereits bei ca. 87'000 Punkten ihr Maximum erreichte, wurde der Gurobi-Solver nicht getestet. 
\end{German}

\begin{English}
    The geometric reconstruction was performed using the PolyFit framework in Python. The source code, written in C++, is available on GitHub \cite{nanLiangliangNanPolyFit2025}. To utilize the functions in Python, a corresponding Python binding was created using CMake. Additionally, the Python library \textit{Easy3D}, also developed at TU Delft, was required for the first step of the PolyFit workflow - surface extraction using RANSAC \cite{nanLiangliangNanEasy3D2025}.

    Since the bindings need to be manually compiled for the target platform (operating system and Python version), the setup process is relatively complex. Therefore, the developed script cannot be easily adopted by other users, which currently limits the productive use of the pipeline.

    No invariant parameters were found for the geometric reconstruction that reliably produce good mesh models for different buildings. Therefore, a brute-force approach was chosen, where the voxel size was iterated to generate a variety of mesh models. The model with the subjective best quality was then selected. This model was created from a point cloud with approximately 87,000 points, which corresponds to about one-tenth of the original point cloud. For point counts above approximately 150,000 points, the optimization problem became too complex and led to program termination. The open-source solver SCIP was used for the calculations. The commercial Gurobi solver is available free of charge for scientific projects and is expected to offer better performance \cite{nanLiangliangNanPolyFit2025}, potentially allowing for a higher point count. However, since the model quality already reached its maximum at around 87,000 points, the Gurobi solver was not tested.
\end{English}

\section{Semantic Segmentation}
\begin{German}
    Die semantische Segmentierung erfolgte mit dem in Kapitel \ref{sec:semantic_segmentation} beschriebenen Framework, das in Python implementiert wurde. Dabei wurden die Flächen identifiziert, segmentiert und jeweils isoliert als .obj-Dateien exportiert. Die zugehörige Klassifikation wurde im Dateinamen codiert, um den Einsatz zusätzlicher Hilfsdateien zu vermeiden.
\end{German}

\begin{English}
    The semantic segmentation was performed using the framework described in Chapter \ref{sec:semantic_segmentation}, which was implemented in Python. The surfaces were identified, segmented, and each exported as .obj files. The associated classification was encoded in the filename to avoid the use of additional auxiliary files.
\end{English}

\section{Modeling}
\begin{German}
    Der erste Teil der automatisierten Modellierung, die Erstellung des IFC-Modelles, erfolgte in Python. Dafür wurde die Bibliothek \textit{ifcopenshell} verwendet, die eine Schnittstelle für die IFC-Datenstruktur bereitstellt \cite{IfcOpenShellOpenSource}. Die .obj-Dateien der segmentierten Flächen wurden eingelesen und in das IFC-Modell integriert. Das IFC-Modell wurde anschliessend als .ifc-Datei exportiert. Damit wurde ein Grundmodell erstellt, das in verschiedenen BIM-Softwarelösungen weiterverarbeitet werden kann.
    
    Der zweite Teil der automatisierten Modellierung, die Parametrisierung der IFC-Bauteile, erfolgte in der BIM-Software \textit{Revit} von \textit{Autodesk}. Das IFC-Modell wurde importiert und mit Revit-Funktionen manuell parametrisiert. Dieser Arbeitsablauf wurde anschliessend mit \textit{Dynamo} automatisiert. \textit{Dynamo} ist eine visuelle Programmierumgebung, die seit 2020 standardmässig in \textit{Revit} integriert ist \cite{DynamoBIM}.
    
    Das zu diesem Zeitpunkt erstellt Modell durfte einen Detailierungsgrad von LoD 200 aufgewiesen haben. Da nicht klar war, ob das Modell damit bereits den Anforderungen für die Baueingabepläne genügen wurden, wurde das Amt für Baubewilligungen der Stadt Zürich für eine grundsätzliche Einschätzung kontaktiert. 
    
    \begin{quote}
        Bei der Bewilligung von Mobilfunkanlagen sind je nach Lage und Zone unterschiedliche gestalterische Anforderungen zu beachten. Deshalb genügt eine reines Volumenmodell nicht. Es sind auch alle gliedernden Elemente in den An- und Aufsichten darzustellen. \cite{amtfurbaubewilligungenthomasfeyerAW_Bachelorarbeit_Anfrage}
    \end{quote}

    Die Auskunft der Bauverwaltung zeigte, dass das Modell in seiner aktuellen Form nicht den Anforderungen für die Baueingabepläne genügte. Es wurde daher entschieden, dass das Modell auf LoD 300 anzuheben.
    
    Die Verfeinerung des Modells wurde anschliessend manuell in \textit{Revit} durchgeführt. Dafür wurden Fenster und Balkonbrüstungen in das Modell integriert. Die eingefügten Bauteile dienten dabei lediglich der Veranschaulichung des Arbeitsablaufs und wurden nicht exakt positioniert. Um den Aufwand zu gering zu halten, wurden für die Fenster bereits vorinstallierte Revit-Familien verwendet. Die Balkonbrüstungen wurden als einfache Wände modelliert. Zudem beschränkten sich die Verbesserungen auf die zwei in den Baueingabeplänen dargestellten Ansichten. 
    Ebenfalls verbessert wurde der Dachbereich. Der fehlende Dachaufbau wurde nachmodelliert. Dieser ist sowohl für die Baueingabepläne als auch für die technische Anlageplanung relevant. Für die Darstellung der Antennenmasten konnte auf eine von Axians bereitsgestellte Revit-Familie zurückgegriffen werden.

    Aus dem Modell wurden anschliessend die Baueingabepläne generiert. Dafür wurde ein vordefiniertes Planlayout verwendet. Auf eine Anpassung wurde verzichtet, da die Pläne lediglich der Veranschaulichung dienen. Zum Schluss wurde eine Visualisierung des Modells erstellt. Dafür wurde in \textit{Infraworks} ein Umgebungsmodell generiert, dass über \textit{Navisworks} in \textit{Revit} importiert werden konnte.    
\end{German}

\begin{English}
    The first part of the automated modeling, the creation of the IFC model, was done in Python. The library \textit{ifcopenshell} was used, which provides an interface for the IFC data structure \cite{IfcOpenShellOpenSource}. The .obj files of the segmented surfaces were read in and integrated into the IFC model. The IFC model was then exported as an .ifc file, creating a base model that can be further processed in various BIM software solutions.
    
    The second part of the automated modeling, the parameterization of the IFC components, was done in the BIM software \textit{Revit} by \textit{Autodesk}. The IFC model was imported and manually parameterized using Revit functions. This workflow was then automated with \textit{Dynamo}, a visual programming environment that has been integrated into \textit{Revit} since 2020 \cite{DynamoBIM}.
    
    At this point, the created model was expected to have a Level of Detail (LoD) of 200. Since it was unclear whether the model already met the requirements for building application plans, the Building Permit Office of the City of Zurich was contacted for a general assessment.
    
    \begin{quote}
        When approving mobile radio installations, different design requirements must be observed depending on location and zone. Therefore, a pure volume model is not sufficient. All structuring elements must also be represented in the elevations. \cite{amtfurbaubewilligungenthomasfeyerAW_Bachelorarbeit_Anfrage}
    \end{quote}

    The response from the building authority indicated that the model in its current form did not meet the requirements for building application plans. It was therefore decided to raise the model to LoD 300.
    
    The refinement of the model was then carried out manually in \textit{Revit}. Windows and balcony railings were integrated into the model. The inserted components were only for illustrative purposes and were not positioned precisely. To keep the effort minimal, pre-installed Revit families were used for the windows. The balcony railings were modeled as simple walls. Additionally, improvements were limited to the two views presented in the building application plans.
    The roof area was also improved by modeling the missing roof structure, which is relevant for both building application plans and technical facility planning. For representing antenna masts, a Revit family already provided by Axians was used.

    Finally, the building application plans were generated from the model using a predefined plan layout. No adjustments were made, as the plans were only for illustrative purposes. A visualization of the model was also created. An environmental model was generated in \textit{Infraworks}, which could be imported into \textit{Revit} via \textit{Navisworks}.
\end{English}